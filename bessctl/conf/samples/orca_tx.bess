# Copyright (c) 2014-2017, The Regents of the University of California.
# Copyright (c) 2016-2017, Nefeli Networks, Inc.
# All rights reserved.
#
# Description: Full mDC agent including file_reader, file_writer and mdc_agent for making an
#  autonomous agent.

import mdcpkts
import time

# Agent IDs we use 
# port1: 4
# port2: 16
# port3: 64
SOCKET_PATH = "/local-scratch/pyassini/domain_socket_file"
AGENT_ID = 1
AGENT_LABEL = 0x01
AGENT_NIC = '0000:7e:00.0'
SWITCH_MAC = '06:a6:7e:72:37:92'
AGENT_MAC = '06:9f:da:98:a4:76'
#AGENT_MAC = '02:53:55:4d:45:01'
num_cores = 8
total_packet_size = 0
data_pkt_size = int($ORCA_DATA_PKT_SIZE!'1024')

print("This is the Orca agent tx script")


ip_list = [
('7.38.233.147', '55.169.157.31'),
('208.97.72.186', '157.28.205.149'),
('117.199.131.176', '79.219.231.247'),
('213.151.109.0', '44.122.57.30'),
('138.101.141.33', '197.122.187.56'),
('228.93.108.53', '64.211.103.156'),
('178.204.3.28', '4.63.60.250'),
('16.123.19.226', '10.199.212.27'), 
]

pkt_template0 = mdcpkts.make_mdc_unlabeled_data_pkt(label=0x50505000, pkt_len=data_pkt_size,\
	src_mac='06:16:3e:1b:72:32', dst_mac='02:53:55:4d:45:01',\
	src_ip=ip_list[0][0], dst_ip=ip_list[0][1],\
	ip_encap=False)

pkt_template1 = mdcpkts.make_mdc_unlabeled_data_pkt(label=0x50505000, pkt_len=data_pkt_size,\
	src_mac='06:16:3e:1b:72:32', dst_mac='02:53:55:4d:45:01',\
	src_ip=ip_list[1][0], dst_ip=ip_list[1][1],\
	ip_encap=False)

pkt_template2 = mdcpkts.make_mdc_unlabeled_data_pkt(label=0x50505000, pkt_len=data_pkt_size,\
	src_mac='06:16:3e:1b:72:32', dst_mac='02:53:55:4d:45:01',\
	src_ip=ip_list[2][0], dst_ip=ip_list[2][1],\
	ip_encap=False)

pkt_template3 = mdcpkts.make_mdc_unlabeled_data_pkt(label=0x50505000, pkt_len=data_pkt_size,\
	src_mac='06:16:3e:1b:72:32', dst_mac='02:53:55:4d:45:01',\
	src_ip=ip_list[2][0], dst_ip=ip_list[3][1],\
	ip_encap=False)
print("Packet template len: " + str(len(pkt_template0)))
total_packet_size =  len(pkt_template0)

print('Data size = %d' % data_pkt_size)
print('Total pkt size = %d' % total_packet_size)
print('Core count = %d' % num_cores)

mdc_receiver0 = MdcReceiver(agent_id=AGENT_ID,
                           agent_label=AGENT_LABEL,
                           switch_mac=SWITCH_MAC,
                           agent_mac=AGENT_MAC, 
                           ip_encap=False)

mdc_receiver1 = MdcReceiver(agent_id=AGENT_ID,
                           agent_label=AGENT_LABEL,
                           switch_mac=SWITCH_MAC,
                           agent_mac=AGENT_MAC, 
                           ip_encap=False)
mdc_receiver2 = MdcReceiver(agent_id=AGENT_ID,
                           agent_label=AGENT_LABEL,
                           switch_mac=SWITCH_MAC,
                           agent_mac=AGENT_MAC, 
                           ip_encap=False)

#mdc_receiver3 = MdcReceiver(agent_id=AGENT_ID,
#                           agent_label=AGENT_LABEL,
#                           switch_mac=SWITCH_MAC,
#                           agent_mac=AGENT_MAC, 
#                           ip_encap=False)

# Adds (session address, label) tuples to the MdcReceiver module
mdc_receiver0.add(entries=[{'addr': '02:53:55:4d:45:01', 'label': 0x50505000}])
mdc_receiver1.add(entries=[{'addr': '02:53:55:4d:45:01', 'label': 0x50505000}])
mdc_receiver2.add(entries=[{'addr': '02:53:55:4d:45:01', 'label': 0x50505000}])
#mdc_receiver3.add(entries=[{'addr': '02:53:55:4d:45:01', 'label': 0x50505000}])

# If in NUMA system, ensure to use CPU cores in the same socket of your NIC.
# TODO: this needs to depend on the CPU layout and where the NIC is.
start_core = 30
for i in range(num_cores):
    bess.add_worker(wid=i, core=i + start_core)

# Define Ports and Queues
port0::PMDPort(port_id=0, num_inc_q=1, num_out_q=4, size_out_q=4096)

#port1::PMDPort(port_id=1, num_inc_q=1, num_out_q=1, size_out_q=4096)

#port0_inc0::QueueInc(port=port0, qid=0)
port0_out0::QueueOut(port=port0, qid=0)
port0_out1::QueueOut(port=port0, qid=1)
port0_out2::QueueOut(port=port0, qid=2)
#port1_inc0::QueueInc(port=port1, qid=0)
#port1_out0::QueueOut(port=port1)

# Traffic generator: this generates data pkts unlike the MdcPktGen that generate ctrl pkts
# Recommended: Use when the NIC has at least 2 ports, and when you want to generate traffic using BESS
# Data rate depends on the capacity (Gbps), and data_pkt_size and Ethernet framing overhead (bytes)
tgen_pkt_rate = (7.41 * 1e9 / float(total_packet_size * 8)) / 3
bess.add_tc('tgen_0', policy='rate_limit', resource='packet', limit={'packet': int(tgen_pkt_rate)})
bess.add_tc('tgen_1', policy='rate_limit', resource='packet', limit={'packet': int(tgen_pkt_rate)})
bess.add_tc('tgen_2', policy='rate_limit', resource='packet', limit={'packet': int(tgen_pkt_rate)})
# Creates a source, and limits its pkt rate

tgen_src_0::Source()
tgen_src_0.attach_task('tgen_0')
tgen_src_1::Source() 
tgen_src_1.attach_task('tgen_1')
tgen_src_2::Source()
tgen_src_2.attach_task('tgen_2')
# Sends generated traffic on Port1
tgen_src_0 -> Rewrite(templates=[bytes(pkt_template0)]) \
	-> 0:mdc_receiver0:0 -> q_out0::Queue(backpressure=1) -> port0_out0

tgen_src_1 -> Rewrite(templates=[bytes(pkt_template1)]) \
	-> 0:mdc_receiver1:0 -> q_out1::Queue(backpressure=1) -> port0_out1

tgen_src_2 -> Rewrite(templates=[bytes(pkt_template2)]) \
	-> 0:mdc_receiver2:0 -> q_out2::Queue(backpressure=1) -> port0_out2

# q_out.attach_task(wid=0)
# tgen_src_0.attach_task(wid=1)
# tgen_src_1.attach_task(wid=2)
#bess.resume_all()
#while(1):
#    time.sleep(2)
#    ret = m.get_summary(clear=False,  # reset stats every interval
#                        latency_percentiles=[55, 99],
#                        jitter_percentiles=[55, 99])
#    #print (ret.timestamp)
#    print ("\nNum Packets: " + str(ret.packets))
#    print ("Max Latency: " + str(ret.latency.max_ns) + " ns")
#    print ("Avg Latency: " + str(ret.latency.avg_ns) + " ns")
#    print ("Sum of latencies: " + str(ret.latency.total_ns) + " ns")
#    print ("\n****************************")

